<html>
<head>
</head>
<body>
<canvas id="render_canvas" style="border: none;" width="700" height="700"></canvas>

<script src="three.js"></script>
<script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
<script type="x-shader/x-vertex" id="vertexshader">
        //  attribute vec3 position;

        uniform vec3 camera_pos;
        varying vec3 NormRef;

        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );


            vec3 normalDirection = normalize(vec3(vec4(normal, 0.0) * modelMatrix));
            vec3 viewDirection = vec3(modelMatrix * vec4(position, 1.0) - vec4(camera_pos, 1.0));
            NormRef = reflect(viewDirection, normalize(normalDirection));
        }
    </script>

<script type="x-shader/x-fragment" id="fragmentshader">
        uniform samplerCube texture_cube;

        varying vec3 NormRef;
        void main() {
            vec4 color = vec4(textureCube(texture_cube, NormRef));
            gl_FragColor = textureCube(texture_cube, NormRef);
            gl_FragColor=clamp(color,0.0,1.0);
        }
    </script>

<script type="x-shader/x-vertex" id="vertexshaderR">
        //  attribute vec3 position;

        uniform vec3 camera_pos;
        varying vec3 NormRef;

        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );


            vec3 normalDirection = normalize(vec3(vec4(normal, 0.0) * modelMatrix));
            vec3 viewDirection = vec3(modelMatrix * vec4(position, 1.0) - vec4(camera_pos, 1.0));
            NormRef = reflect(viewDirection, normalize(normalDirection));
        }
</script>

<script type="x-shader/x-fragment" id="fragmentshaderR">
        uniform samplerCube texture_cube;

        varying vec3 NormRef;
        void main() {
            vec4 color = vec4(textureCube(texture_cube, NormRef));
            gl_FragColor = textureCube(texture_cube, NormRef);
            gl_FragColor=clamp(color,0.0,1.0);
        }
    </script>


<script>
    var start = Date.now();
    var scene = new THREE.Scene();
    var render_canvas = document.getElementById("render_canvas");
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerWidth, 0.1, 1000 );
    var renderer = new THREE.WebGLRenderer( {canvas: render_canvas, antialias: true });
    var geometry = new THREE.SphereGeometry( 1, 100, 100 );
    var cubecamera = new THREE.CubeCamera(.1, 1000, 512);
    /* Envi cube texture */
    var enviurls = ["textures/posx.jpg", "textures/negx.jpg", "textures/posy.jpg", "textures/negy.jpg", "textures/posz.jpg", "textures/negz.jpg"];
    var enviloader = new THREE.CubeTextureLoader();
    var envitex = enviloader.load(enviurls);
    var envishad = THREE.ShaderLib["cube"];
    envishad.uniforms["tCube"].value = envitex;
    var envimtl = new THREE.ShaderMaterial({
        fragmentShader: envishad.fragmentShader,
        vertexShader: envishad.vertexShader,
        uniforms: envishad.uniforms,
        depthWrite: false,
        side: THREE.BackSide
    });
    var envimesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), envimtl);
    scene.add(envimesh);
    /* Reflection mtl creating */
    cubecamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
    scene.add(cubecamera);

    var refuniforms = {
        camera_pos: {type: "v3", value: camera.position},
        texture_cube: {type: "t", value: cubecamera.renderTarget}
    };

    var refmtl = new THREE.ShaderMaterial({
        vertexShader:document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
        uniforms: refuniforms
    });

    var cubematerial = new THREE.MeshBasicMaterial({ envMap: cubecamera.renderTarget.texture });
    var cube = new THREE.Mesh( new THREE.IcosahedronGeometry(5, 5), refmtl );
    scene.add( cube );

    var camL, camR;
    var camU, camD;
    var goF, goB;
    var goL, goR;
    var goC, goSp;
    window.onkeydown = function(e) {

        //D
        if (e.keyCode === 39)
          camL = 1;
                //A
        else if (e.keyCode === 37)
                camR = 1;
        else if (e.keyCode === 38)
                camU = 1;
        else if (e.keyCode === 40)
            camD = 1;

        if (e.keyCode === 68)
                goR = 1;
        else if (e.keyCode === 65)
                goL = 1;
        else if (e.keyCode === 87)
                goF = 1;
        else if (e.keyCode === 83)
            goB = 1;
        else if (e.keyCode === 67)
                goC = 1;
        else if (e.keyCode === 32)
                goSp = 1;
    }

    window.onkeyup = function (e){

        //alert(e.keyCode);
        if (e.keyCode === 39)
                camL = 0;
        else if (e.keyCode === 37)
            camR = 0;
        else if (e.keyCode === 38)
            camU = 0;
        else if (e.keyCode === 40)
            camD = 0;

        if (e.keyCode === 68)
            goR = 0;
        else if (e.keyCode === 65)
            goL = 0;
        else if (e.keyCode === 87)
            goF = 0;
        else if (e.keyCode === 83)
            goB = 0;
        else if (e.keyCode === 67)
            goC = 0;
        else if (e.keyCode === 32)
            goSp = 0;
    }

    // event.type must be keypress
    function getChar(event) {
        if (event.which == null) {
            return String.fromCharCode(event.keyCode);
        } else if (event.which!=0 && event.charCode!=0) {
            return String.fromCharCode(event.which);
        } else {
            return null; // special key
        }
    }

    /* Spheres */
    var sphere = new THREE.Mesh(new THREE.SphereGeometry(.5, 100, 100), new THREE.MeshBasicMaterial( { color: 0x00ff00 } )),
            sphere2 = new THREE.Mesh(new THREE.SphereGeometry(.5, 100, 100), new THREE.MeshBasicMaterial( { color: 0xff0000 } )),
            sphere3 = new THREE.Mesh(new THREE.SphereGeometry(.5, 100, 100), new THREE.MeshBasicMaterial( { color: 0x0000ff } ));

    scene.add(sphere3);
    scene.add(sphere);
    scene.add(sphere2);
    //sphmtl = new THREE.MeshBasicMaterial({ color: 0xff0000 } );

    camera.position.z = 10;
    camera.position.y = 3;
    function render() {
        requestAnimationFrame( render );
        var elapsed_time = (Date.now() - start) / 1000.0;
        //cube.rotation     .set(1.5 * elapsed_time, elapsed_time, 0.5 * elapsed_time);
        if (camR)
          camera.rotation.set(camera.rotation.x, camera.rotation.y + 0.05, camera.rotation.z);
        if (camL)
            camera.rotation.set(camera.rotation.x, camera.rotation.y - 0.05, camera.rotation.z);
        if (camU)
            camera.rotation.set(camera.rotation.x + 0.05, camera.rotation.y, camera.rotation.z);
        if (camD)
            camera.rotation.set(camera.rotation.x - 0.05, camera.rotation.y, camera.rotation.z);
        if (goF)
            camera.position.set(camera.position.x, camera.position.y, camera.position.z - 0.05);
        if (goB)
            camera.position.set(camera.position.x, camera.position.y, camera.position.z + 0.05);
        if (goL)
            camera.position.set(camera.position.x - 0.05, camera.position.y , camera.position.z);
        if (goR)
            camera.position.set(camera.position.x + 0.05, camera.position.y , camera.position.z);
        if (goC)
            camera.position.set(camera.position.x, camera.position.y - 0.05, camera.position.z);
        if (goSp)
            camera.position.set(camera.position.x, camera.position.y + 0.05, camera.position.z);

        cube.visible = false;
        cubecamera.updateCubeMap(renderer, scene);
        cube.visible = true;

        var ca = 10;
        sphere.position.x = Math.sin(elapsed_time) * ca;
        sphere.position.z = Math.sin(elapsed_time + 3 * 3.14 / 2) * ca;
        sphere2.position.y = Math.sin(elapsed_time + 3.14 / 2) * ca;
        sphere2.position.z = Math.sin(elapsed_time) * ca;
        sphere3.position.x = Math.sin(elapsed_time) * ca;
        sphere3.position.z = Math.sin(elapsed_time) * ca;
        sphere3.position.y = Math.sin(elapsed_time + 3 * 3.14 / 2) * ca;
        //sphere.position. = Math.sin(elapsed_time * 2) * 2;
        renderer.render( scene, camera );
    }
    render()
</script>

<div id="log">&nbsp;</div>
</body>
</html>